#!/bin/bash
. ./funcfile #---------------------> подключение библиотеки
# это комментарий
: #--------------------------------> ничего не делающий оператор
var0=10 #--------------------------> присвоение переменной
var1=$var #------------------------> присвоение переменной
var2=`date` #----------------------> присвоение вывода команды
var3=$(date) #---------------------> присвоение вывода команды
var4=$((4+3)) #--------------------> присвоение арефметического решения
var5=$[4 + 3] #--------------------> присвоение арефметического решения
var6=`echo "scale=4; 4/5" | bc` #--> присвоение десятичного числа
var7=`expr length "ldf"` #---------> присвоение длины строки
var=${#var} #----------------------> длина var
var=${var:-str} #------------------> если var не определён подставить str
var=${var:=str} #------------------> если var не определён присвоит var=str
var=${var:?str} #------------------> если var не определён выведет ошибку str
var=${var:+str} #------------------> если var определён подставится
var=${var%шаблон} #----------------> удалить шаблон справо var;  %%
var=${var#шаблон} #----------------> удалить шаблон слево var;  ##
var=${var:start:long} #------------> изъятие подстроки
declare -r VAR="value" #-----------> константа
declare -i var=1 #-----------------> присвоение int

list=(1 2 3) #---------------------> список
echo $list #-----------------------> вернёт первый элимент
echo ${list[@]} #------------------> вернёт весь список

$0 ${10} #-------------------------> параметр командной строки
$# #-------------------------------> общее число параметров
$* #-------------------------------> све параметры как одина строка
$@ #-------------------------------> параметры списком
${!#} #----------------------------> значение последнего параметра
$! #-------------------------------> pid завершённого процесса
$$ #-------------------------------> pid текущего процесса
$? #-------------------------------> значение которое вернул процесс

`whoami` #-------------------------> выполнит команду
"$PATH" #--------------------------> учитывает переменные и спецсимволы
'string' #-------------------------> спец символы/подстановка не активны

$ #--------------------------------> приглошение
# #--------------------------------> режим root
. #--------------------------------> текущий каталог
.. #-------------------------------> родительский каталог по отношению к текущему
- #--------------------------------> предыдущий каталог
> #--------------------------------> stdout перезаписать
>> #-------------------------------> stdout добавить
2> #-------------------------------> stderr
&> #-------------------------------> stdout and atderr
/dev/null #------------------------> битоприёмник
>&2 #------------------------------> разовое перенаправление

0 #--------------------------------> true
1 #--------------------------------> false
[[]] #-----------------------------> true == 0
(()) #-----------------------------> true == 1
<() #------------------------------> как будто из файла
{com ; com ; } #-------------------> группировка команд
bash -c "" #-----------------------> выполнить строку как команду

IFS_OLD=$IFS #---------------------> временное назначение символа-разделителя
IFS=$'\n'
script
IFS=$IFS_OLD

PS3=">>" --------------------------> вторичное приглашение 

\033[0;30m
\033[5;41m ---------------> цвет символа

* ------------------------> любое количество любых символов
? ------------------------> одинлюбой символ
! ------------------------> подстановка команды из истории
[abc] --------------------> любой из перечисленных символов
[!abc] -------------------> любой кроме перечисленных символов
[ab1-9Ai] ----------------> один из указанных символов
[!a-b1-9] ----------------> один символ кроме указанных
[:digit:] ----------------> числовой символ
[:alpha:] ----------------> алфавитный символ внезависемости от регистра
[:alnum:] ----------------> любой алфавитный и числовой символ
[:punct:] ----------------> знак припенания
[:blank:] ----------------> пробел/tab
[:space:] ----------------> пробел
[:graph:] ----------------> всё кроме пробела
[:upper:] ----------------> только в верхнем регистре
[:lower:] ----------------> только в нижнем регистре
[:cntrl:] ----------------> управляющий символ
[:print:] ----------------> всё кроме управляющего символа
[:xdigit:] ---------------> 16 число
a{1..3}b -----------------> подстановка

function name {
    local var='echo "$@"' #> собираем список 
}

name ${arr[*]} #-----------> вызываем функцию разобрав список

# ------------------------------------------------------------------
if command_1; then # --------------> выполнение команды, возврат 0/1
    command_a
elif [ $var0 -qt $var1 ]; then # --> сравнение чисел
    command_b
elif [ $str1 \> $str2 ]; then # ---> сравнение строк
    command_c
elif [ -d $HOME ]; then # ---------> сравнение файлов
    command_d
elif [ command ] && [ command ] # -> сравнение возвращённых значений
    command_e
elif [[ $USER == m* ]]; then # ----> сравнение с шаблоном
    command_f
elif (( 5 * 5 > 9 )); then # ------> сравнение мат. выражения
    command_g
else
    command_h
fi

# -----------------------------------------------------------------
case $var in
    pattern1) command;;
    pattern2) command;;
           *) default command;;
esac

# ------------------------------------------------------------------
for var in `cat $list`; do
    echo "$var"
done

for var in {01..100}
for var in "${list[@]}"
# ------------------------------------------------------------------
for (( i = 0; i < 5; i++ )); do
    echo "$i"
done

# ------------------------------------------------------------------
while test; do
    echo command
done

break
continue
done > output.txt --------------------> перенаправит вывод

# ------------------------------------------------------------------
while getopts ':ab:c' var; do #-------> обработка флагов
    case "$var" in
    a) echo "you use option 'a'";;
    b) argB=$OPTARG
       echo $((argB * 2));;
    c) echo "you use option 'c'";;
    ?) echo "Usage: $0 option [-a] [-b int argument] [-c]"
    exit 1;;
    esac
done

shift $(($OPTIND - 1))
echo "variable one is: $1"
exit 0 #---------------------------> выход из скрипта

#------------------------------------------------------------
select option in a b c; do #-------> меню выбора
    command
done

-a Показать все объекты
-c Подсчитать количество
-d Задать каталог
-e Развернуть объект
-f Указать файл, предназначенный для чтения данных из него
-h Отобразить справочное сообщение, относящееся к данной команде
-i Игнорировать регистр буквенных символов
-l Сформировать вывод в версии с длинным форматом
-n Использовать неинтерактивный (пакетный) режим
-o Указать выходной файл, в который должен быть перенаправлен весь вывод
-q Выполнять работу в режиме без вывода сообщений
-r Обрабатывать каталоги и файлы рекурсивно
-s Выполнять работу в режиме без вывода сообщений
-v Формировать подробный вывод
-x Исключить некоторый объект
-y Подразумевать положительные ответы на все вопросы

n1 -eq n2 Возвращает истинное значение, если n1 равно n2.
n1 -ge n2 Возвращает истинное значение, если n1 больше или равно n2.
n1 -gt n2 Возвращает истинное значение, если n1 больше n2.
n1 -le n2 Возвращает истинное значение, если n1 меньше или равно n2.
n1 -lt n2 Возвращает истинное значение, если n1 меньше n2.
n1 -ne n2 Возвращает истинное значение, если n1 не равно n2.

str1 = str2 Проверяет строки на равенство, возвращает истину, если строки идентичны.
str1 != str2 Возвращает истину, если строки не идентичны.
str1 < str2 Возвращает истину, если str1 меньше, чем str2.
str1 > str2 Возвращает истину, если str1 больше, чем str2.
-n str1 Возвращает истину, если длина str1 больше нуля.
-z str1 Возвращает истину, если длина str1 равна нулю.

-d file Проверяет, существует ли файл, и является ли он директорией.
-e file Проверяет, существует ли файл.
-f file Проверяет, существует ли файл, и является ли он файлом.
-r file Проверяет, существует ли файл, и доступен ли он для чтения.
-s file Проверяет, существует ли файл, и не является ли он пустым.
-w file Проверяет, существует ли файл, и доступен ли он для записи.
-x file Проверяет, существует ли файл, и является ли он исполняемым.
file1 -nt file2 Проверяет, новее ли file1, чем file2.
file1 -ot file2 Проверяет, старше ли file1, чем file2.
-O file Проверяет, существует ли файл, и является ли его владельцем текущий пользователь.
-G file Проверяет, существует ли файл, и соответствует ли его идентификатор
                        группы идентификатору группы текущего пользователя.
# ----------------------------------------------------------------

grep
    -n -------------------> номер строки
    -i -------------------> игнорировать регистр
    -c -------------------> количество совпадений
    -l -------------------> список файлов с совпадениями
    -h -------------------> не выводить имена файлов
    -v -------------------> инвертировать вывод
    -f -------------------> взять паттерн из файла
    -x -------------------> строгая строка
    --color=auto ---------> цветной паттерн в выводе
^ ------------------------> начало строки
$ ------------------------> конец строки
\< -----------------------> начало слова
\> -----------------------> конец слова
[aeF0-9?] ----------------> один из указанных символов
[^a-f] -------------------> любой символ кроме указанного
(a|b) --------------------> или
. ------------------------> любой один символ
() -----------------------> группировка с запоминанием
\1 -----------------------> ссылка на групперовку
a? -----------------------> необязательный символ квантифекаторы
a* -----------------------> любое количество необязательных символов
a+ -----------------------> должен быть минемум 1 необ. символ
{1,5} --------------------> интервальный квантифекатор
{5} ----------------------> точное количество раз
{,3} ---------------------> немение
\ ------------------------> экранирование

dialog --title text --widget text height width 2> file.txt
calendar     Предоставляет календарь, в котором может быть выбрана дата
checklist    Отображает несколько элементов и позволяет указывать,
             какие из этих элементов должны быть включены или выключены
form         Позволяет построить форму с надписями и текстовыми полями,
             предназначенными для заполнения
fselect      Предоставляет окно выбора файла, с помощью которого можно
             перейти к месту нахождения файла и выбрать его
gauge        Отображает измерительную шкалу, показывающую процентную долю выполнения
infobox      Отображает сообщение, на которое не требуется ответ
inputbox     Отображает отдельное текстовое поле формы для ввода текста
inputmenu    Предоставляет редактируемое меню
menu         Отображает список с вариантами, предназначенными для выбора
msgbox       Отображает сообщение и требует, чтобы пользователь щелкнул на кнопке OK
pause        Отображает измерительную шкалу и показывает статус прохождения указанного
             периода паузы
passwordbox  Отображает отдельное текстовое поле, в котором введенный текст становится скрытым
passwordform Отображает форму с надписями и полями скрытого текста
radiolist    Предоставляет группу элементов меню, среди которых может быть выбран
             только один элемент
tailbox      Отображает текст из файла в окне прокрутки с использованием команды tail
tailboxbg    То же, что и tailbox, но работает в фоновом режиме
textbox      Отображает содержимое файла в окне прокрутки
timebox      Предоставляет окно для выбора часов, минут и секунд
yesno        Выводит простое сообщение с кнопками Да и Нет

gdialog
zenit
--calendar        Отобразить полный календарь на месяц
--entry           Показать диалоговое окно ввода текста
--error           Показать диалоговое окно сообщения об ошибке
--file-selection  Отобразить диалоговое окно с полным именем пути и именем файла
--info            Отобразить информационное диалоговое окно
--list            Вывести диалоговое окно со списком выбора или списком переключателей
--notification    Отобразить значок уведомления
--progress        Вывести диалоговое окно с индикатором хода работы
--question        Вывести диалоговое окно с вопросом и кнопками Yes (Да) и No (Нет)
--scale           Отобразить диалоговое окно определения масштаба
--text-info       Отобразить текстовое поле, содержащее текст
--warning         Отобразить диалоговое окно с предупреждением